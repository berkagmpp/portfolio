<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Bootstrap 5 -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
    <!-- custom css-->
    <link rel="stylesheet" href="custom.css">
    <title>Script</title>
</head>

<body class="row">
    <!-- Top menu navigation -->
    <header class="col-3">
        <nav class="navbar flex-column bg-grey row sticky-top">
            <div class="content px-5">
                <!-- nav list -->
                <div class="navbar-dis row">
                    <ul class="navbar-nav col-6">
                        <li class="nav-item active-link">
                            <a href="home.html" class="nav-link">HOME</a>
                        </li>
                        <li class="nav-item">
                            <a href="ux-ui.html" class="nav-link">UX / UI</a>
                        </li>
                        <li class="nav-item">
                            <a href="html-css.html" class="nav-link">HTML / CSS</a>
                        </li>
                        <li class="nav-item">
                            <a href="js.html" class="nav-link">VANILA JAVASCRIPT</a>
                        </li>
                        <li class="nav-item">
                            <a href="react.html" class="nav-link">REACT</a>
                        </li>
                        <li class="nav-item">
                            <a href="other-graphics.html" class="nav-link">OTHER GRAPHICS</a>
                        </li>
                    </ul>
                </div>
            </div>
        </nav>
    </header>
    <!-- End Header -->

    <!-- Main -->
    <main class="col-9">
        <!-- content -->
        <section class="content row" role="contentinfo">
            <div class="col-12 py-3 whole-text mw-1000" id="tab-one">
                <div class="card border-info">
                    <h4 class="card-header">hoisting</h4>
                    <div class="card-body">
                        <h5 class="card-title">· 호이스팅이 뭐냐</h5>
                        <p class="card-text">Hoisting is a JavaScript mechanism where variables and function declarations are moved to the top of their scope regardless of whether their scope is global or local, before code execution.
                        </p>
                        <p class="card-text secondary">호이스팅은 코드 실행 전에 변수와 함수 선언이 범위가 글로벌이든 로컬이든지간에 해당 범위의 맨 위로 이동하는 자바스크립트 메커니즘이다.
                        </p>
                        <p class="card-text">But, the hoisting mechanism only moves the declaration. The definition or assignment are left in place.
                        </p>
                        <p class="card-text secondary">그러나 호이스팅 메커니즘은 선언을 움직일 뿐이다. 정의 또는 할당은 그 자리에 유지된다.
                        </p>
                        <p class="card-text">And, with the strict mode, introduced in ECMAsctipt5, will not tolerate the use of variables before the declaration. 
                        </p>
                        <p class="card-text secondary">그리고 es5에 나온 strict mode를 사용하면 선언 전에 변수를 사용할 수 없습니다.
                        </p>
                    </div>
                </div>
            </div>
            <div class="col-12 py-3 whole-text mw-1000" id="tab-two">
                <div class="card border-info">
                    <h4 class="card-header">Encapsulation</h4>
                    <div class="card-body">
                        <h5 class="card-title">· 객체지향프로그래밍에서 캡슐화란?</h5>
                        <p class="card-text">Object-Oriented Programming is powerful because it provides a device to prevent changes from propagating when new requirements are added or shifted. 
                            And, one of the top representative devices for this is encapsulation.<br>
                        </p>
                        <p class="card-text secondary">객체 지향 프로그래밍은 새로운 요구사항이 추가되거나 이동될 때 변경이 전파되는 것을 방지하는 장치를 제공하기 때문에 강력합니다. 
                            그리고, 이를 위한 가장 대표적인 장치 중 하나는 캡슐화이다. <br>
                        </p>
                        <p class="card-text">Encapsulation is to simplify the data and action of the object, so that it cannot be seen from the outside. 
                            And it generally refers to combining variables and methods for related or specific aims.
                        </p>
                        <p class="card-text secondary">캡슐화는 객체의 데이터와 동작을 단순화하여 외부에서 볼 수 없도록 하는 것이다. 
                            그리고 일반적으로 관련되거나 특정한 목적을 위해 변수와 방법을 결합하는 것을 말한다.
                        </p>
                        <p class="card-text">For example, if there is a code to give coupons to members in 10 places, 
                            when the conditions for providing coupons are changed to level 2 or higher membership, 
                            we should add the changed conditions to all ten places if the code was not encapsulated. 
                            In this case,  we can create a User class to encapsulate membership and levels,  and a coupon permission method. 
                            Now, with an internal implementation of the class, we can affix the changed condition with less effort, and reduce the overall code impact of the change. 
                        </p>
                        <p class="card-text secondary">예를 들어 10개소의 회원에게 쿠폰을 주는 코드가 있다면 쿠폰 제공 조건이 2등급 이상으로 바뀌었을 때 코드가 캡슐화되지 않았다면 변경된 조건을 10개소에 모두 추가해야 한다. 
                            이 경우 멤버 자격 및 수준을 캡슐화하는 사용자 클래스와 쿠폰 권한 방법을 만들 수 있습니다. 
                            이제 클래스의 내부 구현을 통해 변경된 조건을 적은 노력으로 부착할 수 있으며 변경으로 인한 전반적인 코드 영향을 줄일 수 있습니다.
                        </p>
                        <p class="card-text">In addition to this, encapsulation naturally conceals the information, so, we can prevent damage to the object's information. 
                            It's because the unstable and stable parts are separated to control the effect of the change. 
                            In order to apply this, we encapsulate all changes inside the object, cover up the states,  and open only the actions to the outside. 
                            And if an action is possible only internally, we should also hide the act. 
                        </p>
                        <p class="card-text secondary">이와 더불어 캡슐화는 정보를 자연스럽게 은폐하므로 객체 정보의 손상을 방지할 수 있다. 
                            불안정한 부분과 안정된 부분이 분리되어 변화의 효과를 조절하기 때문입니다. 
                            이를 적용하기 위해 객체 내부의 모든 변경 사항을 캡슐화하고 상태를 은폐하며 작업만 외부에 공개합니다. 
                            그리고 만약 어떤 행동이 내부적으로만 가능하다면, 우리는 또한 그 행동을 숨겨야 한다.
                        </p>
                        <p class="card-text">If we use encapsulation, we can transform the internal implementation of an object without affecting the outside. 
                        </p>
                        <p class="card-text secondary">캡슐화를 사용하면 외부에 영향을 미치지 않고 객체의 내부 구현을 변환할 수 있습니다.
                        </p>
                    </div>
                </div>
            </div>
        </section>
        <!-- End content -->
        <!-- custom javascript -->
        <script src="custom.js"></script>
</body>

</html>